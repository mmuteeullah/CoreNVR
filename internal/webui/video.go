package webui

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// handleStream generates an HLS playlist for a camera
func (s *Server) handleStream(w http.ResponseWriter, r *http.Request) {
	// Extract camera name from URL path: /stream/{camera}/playlist.m3u8
	parts := strings.Split(r.URL.Path, "/")
	if len(parts) < 3 {
		http.Error(w, "Invalid path", http.StatusBadRequest)
		return
	}

	cameraName := parts[2]

	// Check if asking for playlist or segment
	if strings.HasSuffix(r.URL.Path, ".m3u8") {
		s.servePlaylist(w, r, cameraName)
	} else if strings.HasSuffix(r.URL.Path, ".ts") {
		s.serveSegment(w, r, cameraName)
	} else {
		http.Error(w, "Invalid request", http.StatusBadRequest)
	}
}

// servePlaylist serves the HLS playlist generated by FFmpeg
func (s *Server) servePlaylist(w http.ResponseWriter, r *http.Request, cameraName string) {
	// For live streaming, serve the actual m3u8 file created by FFmpeg
	playlistPath := filepath.Join(s.config.Storage.BasePath, cameraName, "live", "stream.m3u8")

	// Check if playlist exists
	if _, err := os.Stat(playlistPath); os.IsNotExist(err) {
		// If live stream isn't ready, return a waiting playlist
		playlist := "#EXTM3U\n"
		playlist += "#EXT-X-VERSION:3\n"
		playlist += "#EXT-X-TARGETDURATION:2\n"
		playlist += "# Stream starting, please wait...\n"

		w.Header().Set("Content-Type", "application/vnd.apple.mpegurl")
		w.Header().Set("Cache-Control", "no-cache")
		w.Write([]byte(playlist))
		return
	}

	// Serve the actual playlist file
	data, err := os.ReadFile(playlistPath)
	if err != nil {
		http.Error(w, "Failed to read playlist", http.StatusInternalServerError)
		return
	}

	// Update segment paths to work with our URL structure
	playlistStr := string(data)
	playlistStr = strings.ReplaceAll(playlistStr, "segment", "/segments/"+cameraName+"/live/segment")

	w.Header().Set("Content-Type", "application/vnd.apple.mpegurl")
	w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
	w.Header().Set("Pragma", "no-cache")
	w.Header().Set("Expires", "0")
	w.Write([]byte(playlistStr))
}

// handleSegments serves the actual video segments
func (s *Server) handleSegments(w http.ResponseWriter, r *http.Request) {
	// Parse URL: /segments/{camera}/{type}/{file.ts}
	// Where type is either "live" or a date like "2024-01-01"
	path := strings.TrimPrefix(r.URL.Path, "/segments/")
	parts := strings.Split(path, "/")

	if len(parts) != 3 {
		http.Error(w, "Invalid segment path", http.StatusBadRequest)
		return
	}

	cameraName := parts[0]
	date := parts[1]
	filename := parts[2]

	// Validate filename (security)
	if strings.Contains(filename, "..") || !strings.HasSuffix(filename, ".ts") {
		http.Error(w, "Invalid filename", http.StatusBadRequest)
		return
	}

	// Build file path
	filePath := filepath.Join(s.config.Storage.BasePath, cameraName, date, filename)

	// Check if file exists
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		http.Error(w, "Segment not found", http.StatusNotFound)
		return
	}

	// Serve the file
	s.serveFile(w, r, filePath)
}

// serveSegment serves a single video segment
func (s *Server) serveSegment(w http.ResponseWriter, r *http.Request, cameraName string) {
	// This is for direct segment access via /stream/{camera}/{segment.ts}
	parts := strings.Split(r.URL.Path, "/")
	if len(parts) < 4 {
		http.Error(w, "Invalid path", http.StatusBadRequest)
		return
	}

	filename := parts[3]
	if !strings.HasSuffix(filename, ".ts") {
		http.Error(w, "Invalid file type", http.StatusBadRequest)
		return
	}

	// Use today's date
	dateStr := time.Now().Format("2006-01-02")
	filePath := filepath.Join(s.config.Storage.BasePath, cameraName, dateStr, filename)

	s.serveFile(w, r, filePath)
}

// serveFile efficiently serves a video file with range support
func (s *Server) serveFile(w http.ResponseWriter, r *http.Request, filePath string) {
	file, err := os.Open(filePath)
	if err != nil {
		http.Error(w, "File not found", http.StatusNotFound)
		return
	}
	defer file.Close()

	stat, err := file.Stat()
	if err != nil {
		http.Error(w, "File error", http.StatusInternalServerError)
		return
	}

	// Set content type for video segments
	w.Header().Set("Content-Type", "video/MP2T")
	w.Header().Set("Accept-Ranges", "bytes")

	// Handle range requests for efficient streaming
	rangeHeader := r.Header.Get("Range")
	if rangeHeader != "" {
		// Parse range header and serve partial content
		http.ServeContent(w, r, filepath.Base(filePath), stat.ModTime(), file)
	} else {
		// Serve full file
		w.Header().Set("Content-Length", fmt.Sprintf("%d", stat.Size()))
		io.Copy(w, file)
	}
}